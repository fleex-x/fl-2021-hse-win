# Домашка

1. [Мой-второй-любимый-язык-программирования](#Мой-второй-любимый-язык-программирования)
1. [Process-Substitution](#Process-Substitution)
1. [local-readonly](#local-readonly)
1. [functions](#functions)
1. [ссылки](#ссылки)

## Мой-второй-любимый-язык-программирования
Моим вторым любимым по счету языком программирования по праву можно назвать bash! (так как кроме плюсов и bash я ничего не знаю).

## Process-Substitution
Представим ситуацию - вы хотите использовать утилиту, которая ожидает на вход имена файлов, а информация у вас совсем не в файлах. При этом создавать временные файлы по возможности не хочется. Тогда есть оператор `<()`, который неявно оборачивает результат работы другой утилиты в файл. Например, можно написать вот так:

```bash
diff <(wget -O - url1) <(wget -O -url2)
```

## local-readonly
В bash по умлочанию все переменные глобальные (даже локальные в функциях) и изменяемые. Не очень-то это хорошо читается, по-этому есть возможность писать `local` и `readonly`.

## functions
Функции в bash есть, но самое приятное это то, что функции можно вызывать по синтаксису точно также, как и утилиты. Например в функции использутся ввод/вывод, а мы хотим их перенаправить. Можно не передавать ничего в качестве аргумента, чтобы так сделать, а просто написать операторы изменения потоков `<` или `>` как при вызове утилиты.
Например вот так:

```bash
printKek () {
	echo "kek"
}
printKek >res.txt
```

## ссылки
Изначально я все это увидел в этой статье `https://habr.com/ru/post/221273/`. Да, это не документация, поэтому позже я все это нашел в документации:
`https://www.gnu.org/software/bash/manual/bash.html#Process-Substitution`
`https://www.gnu.org/software/bash/manual/bash.html#Redirecting-Input`
``
